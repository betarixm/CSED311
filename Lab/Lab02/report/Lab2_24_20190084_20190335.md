Lab 2: RTL Design
===
20190084 권민재, 20190335 양승원 `CSED311`

# Introduction
<!--
- What you have to design & implement
- What you have to learn
-->
 이번 Lab에서는 RTL, 즉 Synchronous Circuit으로 Vending Machine을 구현해야 한다. 이 회로에는 사이클마다 입력되는 동전의 종류, 선택한 아이템 종류, 동전 반환 여부가 입력되며 그 입력에 상응하여 가능한 아이템들, 배출한 아이템, 반환하는 동전을 출력해야한다. 이것은 FSM의 형태로 몇 가지 state를 만들어서 구현할 것이다. 이 과제를 통해 Verilog를 이용하여 Synchrounous Circuit을 다루는 방법을 알아볼 것이다.

# Design
<!--
You should make an effort to write this section.
- How to divide a large module into submodules?
- How does each submodule operate?
- How to interconnect them?
If necessary, add a diagram to your report (handwritten diagram is also allowed)
-->
```mermaid
graph LR
A[1. 돈 입력] --> B[2. 대기 시간 초기화]
D -->|Yes| E[8. 잔돈 반환]
B --> C[3. 아이템 목록 출력]
D --> |No| F{5. 선택한 아이템이<br>출력 가능한가?}
C --> D{4. 대기시간 만료?}
F --> |Yes| G[6. 아이템 출력]
F --> |No| H{7. 돈이 입력<br>되었는가?}
G --> ZZ[Go to 2]
E --> YY[Go to 1]
H --> |Yes|BB[Go to 2]
H --> |No|D
```

## Submodules
### caculate_current_state
```mermaid
graph LR
O[ ] -->|start| INIT((INIT<br>STATE))
INIT --> IDLE((IDLE<br>STATE))
IDLE --> MONEY((MONEY<br>STATE))
IDLE --> ITEM((ITEM<br>STATE))
MONEY --> IDLE
ITEM --> IDLE
```
 이 모듈에서는 위와 같은 FSM에 따라서 다음 state를 계산하고, 현재 state에서 처리해야 할 일을 수행하도록 디자인했다. **INIT STATE**는 vending machine의 초기 state로 지금까지 입력된 동전, 출력한 액수, 반환한 동전의 총합을 0으로 초기화 한다. **IDLE STATE**는 vending machine이 대기하는 state로, available 아이템을 출력하며 반환하는 동전이 있다면 해당 동전의 액수만큼을 반환한 동전의 총합에 더하는 역할을 수행한다. **MONEY STATE**는 돈의 입력을 처리하는 상태로, 돈이 입력될 때 해당 액수만큼을 입력된 동전의 총합에 더한다. 마지막으로, **ITEM STATE**는 아이템을 출력하는 상태로, 선택한 아이템이 available하다면 해당 아이템을 출력한다. 
 맨 처음에 INIT STATE를 벗어난 이후에는 IDLE, MONEY, ITEM STATE들을 오가면서 vending machine이 작동할 수 있도록 디자인하였다. 입력되는 동전이 있을 경우에는 MONEY STATE, 선택한 아이템이 있을 경우에는 ITEM STATE, 그 외 경우에는 IDLE STATE에 있도록 state를 계산하게 디자인하였다.
 
### check_time_and_coin

### change_state

## Top-level module
Top-level module, Vending Machine에서는 위의 submodule들을 조합하는 방식으로 디자인하였다. 

# Implementation
<!--
You should explain your Verilog code.
- The overall structure of your implementation
- A short, but meaningful description for non-trivial modules.
- The interaction between modules when they run a given scenario.
- Do NOT explain too much details of your implementation.
- Do NOT show the waveform results.
-->
## Submodules
### caculate_current_state
 이 모듈에서는 `1. 다음 state를 계산하고`, `2. 현재 state에서의 output` 을 계산하기 위해 크게 2개의 Combinational Logic을 구성하여 구현하였다.
#### Combinational logic for the next states
| Input | Process |
| :------: | -------- |
| `i_input_coin` | 다음 state를 MONEY STATE로 설정하도록 구현했다.|
| `i_select_item`| 다음 state를 ITEM STATE로 설정하였다.|
| 그 외의 경우      | 다음 state를 IDLE STATE로 설정하였다. |


#### Combinational logic for the outputs
|State|Process|
|:---:|:-----|
|INIT| 돈 관련 각종 누산기들을 초기화한다.|
|IDLE| `available_item`을 출력하고, return_coin을 누산한다.|
|MONEY|`i_input_coin`에 따라서 입력된 동전의 총액을 누산한다.|
|ITEM|`i_select_item`에 따라서 돈이 충분할 경우에 해당 아이템을 출력하고, 출력 금액을 누산한다.|


### check_time_and_coin

### change_state


# Discussion

<!--
- write anything valuable that you want to inform
For example:
- Important decisions you made
- Difficulties in designing and implementing, and your solutions for these
- Differences between your design and implementation, and the reasons for these.
- Feedback to TAs
-->
- 처음에는 STATE 2개로 설계하였으나, 클럭을 맞추는 과정에서 STATE를 4개로 쪼개서 만들게 되었다.
- 


# Conclusion

<!--
don’t need to repeat the contents of the introduction section.
Just answer the following question:
- Did you succeed in achieving the goals described in the introduction section?
- If not, which goals could not be achieved? Why?
-->
 이번 Lab을 통해 Verilog로 Synchronous Circuit을 이용한 FSM을 구현해보며 클럭에 따라 비동기적으로 처리되어야 할 상황에서 어떻게 해야하는지 배울 수 있었다. 